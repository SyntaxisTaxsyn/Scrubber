<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Touch Animation Editor</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }

    #canvas {
      position: relative;
      width: 600px;
      height: 400px;
      border: 1px solid #ccc;
      margin-bottom: 20px;
      background-color: #f9f9f9;
    }

    #object {
      position: absolute;
      background-image: url('/Images/gupxCropped.png'); /* Update with the actual file path */
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transform-origin: center;
      touch-action: none;
    }

    #controls, #fields {
      margin-top: 10px;
    }

    button {
      margin-right: 10px;
      padding: 6px 12px;
    }

    input[type="range"] {
      width: 300px;
      vertical-align: middle;
    }

    input[type="number"] {
      width: 60px;
      margin-right: 10px;
    }

    label {
      margin-right: 5px;
    }

    #timelineWrapper {
      position: relative;
      display: inline-block;
    }

    #markerTrack {
      position: absolute;
      top: 50%;
      left: 0;
      height: 8px;
      width: 300px;
      transform: translateY(-50%);
      pointer-events: none;
    }

    .marker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 100%;
      background-color: blue;
    }

    #keyframeTable {
      margin-top: 20px;
      border-collapse: collapse;
      width: 100%;
      max-width: 600px;
    }

    #keyframeTable th, #keyframeTable td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: center;
    }

    #keyframeTable tr:hover {
      background-color: #f0f8ff;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <h2>Touch Animation Editor</h2>

  <div id="canvas">
    <div id="object"></div>
  </div>

  <div id="controls">
    <div id="timelineWrapper">
      <input type="range" id="timeline" min="0" max="100" value="0">
      <div id="markerTrack"></div>
    </div>
    <button id="addKeyframe">Add Keyframe</button>
    <button id="togglePlay">Play</button>
  </div>

  <div id="fields">
    <label>X: <input type="number" id="inputX"></label>
    <label>Y: <input type="number" id="inputY"></label>
    <label>Rotation: <input type="number" id="inputRotation"></label>
    <label>Size: <input type="number" id="inputSize"></label>
    <label>Opacity: <input type="number" id="inputOpacity" min="0" max="1" step="0.01"></label>
    <label>Visible: <input type="checkbox" id="inputVisible"></label>
  </div>

  <table id="keyframeTable">
    <thead>
      <tr>
        <th>Time</th>
        <th>X</th>
        <th>Y</th>
        <th>Rotation</th>
        <th>Size</th>
        <th>Opacity</th>
        <th>Visible</th>
      </tr>
    </thead>
    <tbody>
      <!-- Keyframes go here -->
    </tbody>
  </table>

  <script>
    const object = document.getElementById("object");
    const timeline = document.getElementById("timeline");
    const addKeyframeBtn = document.getElementById("addKeyframe");
    const togglePlayBtn = document.getElementById("togglePlay");

    const inputX = document.getElementById("inputX");
    const inputY = document.getElementById("inputY");
    const inputRotation = document.getElementById("inputRotation");
    const inputSize = document.getElementById("inputSize");
    const inputOpacity = document.getElementById("inputOpacity");
    const inputVisible = document.getElementById("inputVisible");

    const markerTrack = document.getElementById("markerTrack");
    const keyframeTable = document.getElementById("keyframeTable").querySelector("tbody");

    let currentTime = 0;
    let playing = false;
    let playInterval;

    const keyframes = [];

    let currentState = {
      x: 100,
      y: 100,
      size: 50,
      rotation: 0,
      opacity: 1,
      visible: true
    };

    function applyState(state) {
      object.style.left = `${state.x}px`;
      object.style.top = `${state.y}px`;
      object.style.width = `${state.size}px`;
      object.style.height = `${state.size}px`;
      object.style.transform = `rotate(${state.rotation}deg)`;
      object.style.opacity = state.opacity;
      object.style.display = state.visible ? "" : "none";

      inputX.value = Math.round(state.x);
      inputY.value = Math.round(state.y);
      inputRotation.value = Math.round(state.rotation);
      inputSize.value = Math.round(state.size);
      inputOpacity.value = state.opacity;
      inputVisible.checked = state.visible;
    }

    function readInputsToState() {
      currentState.x = parseFloat(inputX.value);
      currentState.y = parseFloat(inputY.value);
      currentState.rotation = parseFloat(inputRotation.value);
      currentState.size = parseFloat(inputSize.value);
      currentState.opacity = parseFloat(inputOpacity.value);
      currentState.visible = inputVisible.checked;
      applyState(currentState);
    }

    inputX.addEventListener("input", readInputsToState);
    inputY.addEventListener("input", readInputsToState);
    inputRotation.addEventListener("input", readInputsToState);
    inputSize.addEventListener("input", readInputsToState);
    inputOpacity.addEventListener("input", readInputsToState);
    inputVisible.addEventListener("change", readInputsToState);

    addKeyframeBtn.addEventListener("click", () => {
      const time = parseFloat(timeline.value);
      const state = { ...currentState, time };
      keyframes.push(state);
      keyframes.sort((a, b) => a.time - b.time);
      renderMarkers();
      renderKeyframeTable();
      console.log("Added keyframe:", state);
    });

    function interpolate(a, b, t) {
      const lerp = (x, y) => x + (y - x) * t;
      return {
        x: lerp(a.x, b.x),
        y: lerp(a.y, b.y),
        size: lerp(a.size, b.size),
        rotation: lerp(a.rotation, b.rotation),
        opacity: lerp(a.opacity, b.opacity),
        visible: a.visible // visibility stays as previous keyframe until next
      };
    }

    function getStateAt(time) {
      if (keyframes.length === 0) return currentState;
      if (time <= keyframes[0].time) return keyframes[0];
      if (time >= keyframes[keyframes.length - 1].time) return keyframes[keyframes.length - 1];

      for (let i = 0; i < keyframes.length - 1; i++) {
        const a = keyframes[i];
        const b = keyframes[i + 1];
        if (time >= a.time && time <= b.time) {
          const progress = (time - a.time) / (b.time - a.time);
          return interpolate(a, b, progress);
        }
      }
      return currentState;
    }

    function updateFromTimeline() {
      currentTime = parseFloat(timeline.value);
      const state = getStateAt(currentTime);
      applyState(state);
    }

    timeline.addEventListener("input", updateFromTimeline);

    togglePlayBtn.addEventListener("click", () => {
      playing = !playing;
      togglePlayBtn.textContent = playing ? "Pause" : "Play";

      if (playing) {
        playInterval = setInterval(() => {
          currentTime += 1;
          if (currentTime > 100) {
            currentTime = 100;
            clearInterval(playInterval);
            playing = false;
            togglePlayBtn.textContent = "Play";
          }
          timeline.value = currentTime;
          updateFromTimeline();
        }, 50);
      } else {
        clearInterval(playInterval);
      }
    });

    function renderMarkers() {
      markerTrack.innerHTML = "";
      keyframes.forEach((kf) => {
        const marker = document.createElement("div");
        marker.className = "marker";
        marker.style.left = `${(kf.time / 100) * 300}px`;
        markerTrack.appendChild(marker);
      });
    }

    function renderKeyframeTable() {
      keyframeTable.innerHTML = "";
      keyframes.forEach((kf, index) => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${kf.time}</td>
          <td>${Math.round(kf.x)}</td>
          <td>${Math.round(kf.y)}</td>
          <td>${Math.round(kf.rotation)}</td>
          <td>${Math.round(kf.size)}</td>
          <td>${kf.opacity.toFixed(2)}</td>
          <td>${kf.visible ? "Yes" : "No"}</td>
        `;
        row.addEventListener("click", () => {
          timeline.value = kf.time;
          updateFromTimeline();
        });
        keyframeTable.appendChild(row);
      });
    }

    applyState(currentState);

    // Drag logic
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };

    function getTouchPos(evt) {
      const touch = evt.touches[0];
      const rect = object.parentElement.getBoundingClientRect();
      return {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      };
    }

    function getMousePos(evt) {
      const rect = object.parentElement.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
    }

    object.addEventListener("touchstart", (e) => {
      e.preventDefault();
      isDragging = true;
      const pos = getTouchPos(e);
      dragOffset.x = pos.x - currentState.x;
      dragOffset.y = pos.y - currentState.y;
    });

    object.addEventListener("touchmove", (e) => {
      if (!isDragging) return;
      const pos = getTouchPos(e);
      currentState.x = pos.x - dragOffset.x;
      currentState.y = pos.y - dragOffset.y;
      applyState(currentState);
    });

    object.addEventListener("touchend", () => {
      isDragging = false;
    });

    object.addEventListener("mousedown", (e) => {
      isDragging = true;
      const pos = getMousePos(e);
      dragOffset.x = pos.x - currentState.x;
      dragOffset.y = pos.y - currentState.y;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      const pos = getMousePos(e);
      currentState.x = pos.x - dragOffset.x;
      currentState.y = pos.y - dragOffset.y;
      applyState(currentState);
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
    });
  </script>
</body>
</html>
